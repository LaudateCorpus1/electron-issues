[
  {
    "url": "https://api.github.com/repos/electron/electron/issues/comments/251803796",
    "html_url": "https://github.com/electron/electron/issues/7490#issuecomment-251803796",
    "issue_url": "https://api.github.com/repos/electron/electron/issues/7490",
    "id": 251803796,
    "user": {
      "login": "kevinsawicki",
      "id": 671378,
      "avatar_url": "https://avatars0.githubusercontent.com/u/671378?v=3",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kevinsawicki",
      "html_url": "https://github.com/kevinsawicki",
      "followers_url": "https://api.github.com/users/kevinsawicki/followers",
      "following_url": "https://api.github.com/users/kevinsawicki/following{/other_user}",
      "gists_url": "https://api.github.com/users/kevinsawicki/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kevinsawicki/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kevinsawicki/subscriptions",
      "organizations_url": "https://api.github.com/users/kevinsawicki/orgs",
      "repos_url": "https://api.github.com/users/kevinsawicki/repos",
      "events_url": "https://api.github.com/users/kevinsawicki/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kevinsawicki/received_events",
      "type": "User",
      "site_admin": true
    },
    "created_at": "2016-10-05T21:23:31Z",
    "updated_at": "2016-10-05T21:23:31Z",
    "body": "/cc @tarruda \n"
  },
  {
    "url": "https://api.github.com/repos/electron/electron/issues/comments/251827848",
    "html_url": "https://github.com/electron/electron/issues/7490#issuecomment-251827848",
    "issue_url": "https://api.github.com/repos/electron/electron/issues/7490",
    "id": 251827848,
    "user": {
      "login": "sltam",
      "id": 51615,
      "avatar_url": "https://avatars3.githubusercontent.com/u/51615?v=3",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sltam",
      "html_url": "https://github.com/sltam",
      "followers_url": "https://api.github.com/users/sltam/followers",
      "following_url": "https://api.github.com/users/sltam/following{/other_user}",
      "gists_url": "https://api.github.com/users/sltam/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sltam/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sltam/subscriptions",
      "organizations_url": "https://api.github.com/users/sltam/orgs",
      "repos_url": "https://api.github.com/users/sltam/repos",
      "events_url": "https://api.github.com/users/sltam/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sltam/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-05T23:23:20Z",
    "updated_at": "2016-10-05T23:23:20Z",
    "body": "I wonder why it ever worked. Inside [`WebContents::~WebContents`](https://github.com/electron/electron/blob/018575de/atom/browser/api/atom_api_web_contents.cc#L399), `GetWrapper()` is called at [`EmitWithEvent`](https://github.com/electron/electron/blob/018575de/atom/browser/api/event_emitter.h#L98), but `~WrapperBase` should have been called before `~WebContents` on this object (`WebContents` inherits `mate::TrackableObject<WebContents>` inherits `mate::EventEmitter<WebContents>` inherits `mate::Wrappable<WebContents>` inherits `mate::WrappableBase`), so [`wrapper_`](https://github.com/zcbenz/native-mate/blob/b5e5de62/native_mate/wrappable_base.h#L56) should have been [reset](https://github.com/zcbenz/native-mate/blob/b5e5de62/native_mate/wrappable.cc#L20). Then why the `!wrapper_.IsEmpty()` check doesn't fail like always?\n"
  },
  {
    "url": "https://api.github.com/repos/electron/electron/issues/comments/251934809",
    "html_url": "https://github.com/electron/electron/issues/7490#issuecomment-251934809",
    "issue_url": "https://api.github.com/repos/electron/electron/issues/7490",
    "id": 251934809,
    "user": {
      "login": "tarruda",
      "id": 842846,
      "avatar_url": "https://avatars0.githubusercontent.com/u/842846?v=3",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tarruda",
      "html_url": "https://github.com/tarruda",
      "followers_url": "https://api.github.com/users/tarruda/followers",
      "following_url": "https://api.github.com/users/tarruda/following{/other_user}",
      "gists_url": "https://api.github.com/users/tarruda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tarruda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tarruda/subscriptions",
      "organizations_url": "https://api.github.com/users/tarruda/orgs",
      "repos_url": "https://api.github.com/users/tarruda/repos",
      "events_url": "https://api.github.com/users/tarruda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tarruda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-06T11:20:52Z",
    "updated_at": "2016-10-06T11:20:52Z",
    "body": "> I wonder why it ever worked.\n\nThe code path followed by sandboxed popups is different. For non-sandboxed, `new-window` is emitted before the window/webcontents are created, so when `event.preventDefault()` is called the the destructor is never called.\n\nFor sandboxed windows the webcontents is created by content module, we just wrap it in an `api::Webcontents`. When the event is prevented, the v8 reference to the webContents should be lost, causing its destructor to be called.\n"
  },
  {
    "url": "https://api.github.com/repos/electron/electron/issues/comments/251940890",
    "html_url": "https://github.com/electron/electron/issues/7490#issuecomment-251940890",
    "issue_url": "https://api.github.com/repos/electron/electron/issues/7490",
    "id": 251940890,
    "user": {
      "login": "tarruda",
      "id": 842846,
      "avatar_url": "https://avatars0.githubusercontent.com/u/842846?v=3",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tarruda",
      "html_url": "https://github.com/tarruda",
      "followers_url": "https://api.github.com/users/tarruda/followers",
      "following_url": "https://api.github.com/users/tarruda/following{/other_user}",
      "gists_url": "https://api.github.com/users/tarruda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tarruda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tarruda/subscriptions",
      "organizations_url": "https://api.github.com/users/tarruda/orgs",
      "repos_url": "https://api.github.com/users/tarruda/repos",
      "events_url": "https://api.github.com/users/tarruda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tarruda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-06T11:55:49Z",
    "updated_at": "2016-10-06T11:55:49Z",
    "body": "BTW, I know sandbox mode is not documented for now, but if you are using it and need to prevent popups, you need to do it on renderer side.\n\nThe reason is that the `CanCreateWindow` function(which is responsible for blocking popups in the content module) will always return true for sandbox, meaning that `window.open` will return a reference to the window even if you prevent it in `new-window`(This could be a problem despite the crash reported in this issue)\n\nI still need to think of a way to expose `CanCreateWindow` to javascript. The problem is that it runs in the IO thread so I'm not sure we can invoke the main javascript isolate from that thread.\n\nA possible solution would be to have a separate v8 isolate for the IO thread, and allow the user to send a function that would be responsible for filtering directly in the IO thread. For example:\n\n``` js\nfunction popupBlocker(url) {\n  if (url === 'https://some.url.com')\n    return false  // block popups opened by some.url.com\n  return true\n}\n\nwin = new BrowserWindow({webPreferences: popupBlocker: popupBlocker.toString()})\n```\n\nAnother way would be to follow google chrome approach: Block all popups by default and send a notification to the main thread about the blocked popup with URL. The main thread(thus javascript code) can then invoke some API to whitelist URLs.\n\nBut I'm not even sure it would be a good idea to follow the content module architecture for this. IMO a better way is to let the electron programmer do it on renderer side:\n\n``` js\n// renderer-preload.js\nconst winOpen = window.open\nwindow.open = function open (...args) {\n  if (url === 'https://some.url.com')\n    return  // block popups opened by some.url.com\n  return winOpen.apply(window, args)\n}\n```\n\nIn the renderer-side scheme it is even possible to use `ipcRenderer` to ask the main process if a popup should be allowed.\n"
  },
  {
    "url": "https://api.github.com/repos/electron/electron/issues/comments/251945818",
    "html_url": "https://github.com/electron/electron/issues/7490#issuecomment-251945818",
    "issue_url": "https://api.github.com/repos/electron/electron/issues/7490",
    "id": 251945818,
    "user": {
      "login": "tarruda",
      "id": 842846,
      "avatar_url": "https://avatars0.githubusercontent.com/u/842846?v=3",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tarruda",
      "html_url": "https://github.com/tarruda",
      "followers_url": "https://api.github.com/users/tarruda/followers",
      "following_url": "https://api.github.com/users/tarruda/following{/other_user}",
      "gists_url": "https://api.github.com/users/tarruda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tarruda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tarruda/subscriptions",
      "organizations_url": "https://api.github.com/users/tarruda/orgs",
      "repos_url": "https://api.github.com/users/tarruda/repos",
      "events_url": "https://api.github.com/users/tarruda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tarruda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-06T12:22:38Z",
    "updated_at": "2016-10-06T12:22:38Z",
    "body": "Right now the best way I can see to solve this issue is to skip emitting \"render-view-deleted\" for webContents created by sandboxed renderers(there shouldn't be any listeners)\n\nHere's part of the gdb stack:\n\n```\n#0  0x00007fffe9b34c37 in __GI_raise (sig=sig@entry=6) at ../nptl/sysdeps/unix/sysv/linux/raise.c:56\n#1  0x00007fffe9b38028 in __GI_abort () at abort.c:89\n#2  0x00007ffff2698da2 in base::debug::BreakDebugger() () from /data/dev/electron/out/D/libbase.so\n#3  0x00007ffff26b41ca in logging::LogMessage::~LogMessage() () from /data/dev/electron/out/D/libbase.so\n#4  0x0000000000a7ee73 in mate::WrappableBase::GetWrapper (this=0xa72e87a17b0)\n    at ../../vendor/native_mate/native_mate/wrappable.cc:24\n#5  0x0000000000b49dd5 in mate::EventEmitter<atom::api::WebContents>::GetWrapper (this=0xa72e87a17b0)\n    at ../../atom/browser/api/event_emitter.h:45\n#6  0x0000000000b50e93 in mate::EventEmitter<atom::api::WebContents>::EmitWithSender<int> (this=0xa72e87a17b0,\n    name=..., sender=0x0, message=0x0, args=@0x7fffffffd75c: 4) at ../../atom/browser/api/event_emitter.h:83\n#7  0x0000000000b4460c in mate::EventEmitter<atom::api::WebContents>::Emit<int> (this=0xa72e87a17b0, name=...,\n    args=@0x7fffffffd75c: 4) at ../../atom/browser/api/event_emitter.h:71\n#8  0x0000000000b3a032 in atom::api::WebContents::RenderViewDeleted (this=0xa72e87a1780,\n    render_view_host=0xa72e88e7280) at ../../atom/browser/api/atom_api_web_contents.cc:626\n#9  0x0000000000b382b6 in atom::api::WebContents::~WebContents (this=0xa72e87a1780)\n    at ../../atom/browser/api/atom_api_web_contents.cc:399\n#10 0x0000000000b38439 in atom::api::WebContents::~WebContents (this=0xa72e87a1780)\n    at ../../atom/browser/api/atom_api_web_contents.cc:388\n#11 0x0000000000a7f258 in mate::WrappableBase::SecondWeakCallback (data=...)\n    at ../../vendor/native_mate/native_mate/wrappable.cc:56\n#12 0x00007ffff6d92667 in v8::internal::GlobalHandles::DispatchPendingPhantomCallbacks(bool) ()\n   from /data/dev/electron/out/D/libv8.so\n#13 0x00007ffff6d926e9 in v8::internal::GlobalHandles::PostGarbageCollectionProcessing(v8::internal::GarbageCollector, v8::GCCallbackFlags) () from /data/dev/electron/out/D/libv8.so\n#14 0x00007ffff6d9f14b in v8::internal::Heap::PerformGarbageCollection(v8::internal::GarbageCollector, v8::GCCallbackFlags) () from /data/dev/electron/out/D/libv8.so\n#15 0x00007ffff6d9e5ae in v8::internal::Heap::CollectGarbage(v8::internal::GarbageCollector, char const*, char const*, v8::GCCallbackFlags) () from /data/dev/electron/out/D/libv8.so\n```\n\nCC @zcbenz \n"
  },
  {
    "url": "https://api.github.com/repos/electron/electron/issues/comments/251946361",
    "html_url": "https://github.com/electron/electron/issues/7490#issuecomment-251946361",
    "issue_url": "https://api.github.com/repos/electron/electron/issues/7490",
    "id": 251946361,
    "user": {
      "login": "tarruda",
      "id": 842846,
      "avatar_url": "https://avatars0.githubusercontent.com/u/842846?v=3",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tarruda",
      "html_url": "https://github.com/tarruda",
      "followers_url": "https://api.github.com/users/tarruda/followers",
      "following_url": "https://api.github.com/users/tarruda/following{/other_user}",
      "gists_url": "https://api.github.com/users/tarruda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tarruda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tarruda/subscriptions",
      "organizations_url": "https://api.github.com/users/tarruda/orgs",
      "repos_url": "https://api.github.com/users/tarruda/repos",
      "events_url": "https://api.github.com/users/tarruda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tarruda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-06T12:25:20Z",
    "updated_at": "2016-10-06T12:25:20Z",
    "body": "If no one can see a better alternative I can send a PR with test case + fix\n"
  },
  {
    "url": "https://api.github.com/repos/electron/electron/issues/comments/252015302",
    "html_url": "https://github.com/electron/electron/issues/7490#issuecomment-252015302",
    "issue_url": "https://api.github.com/repos/electron/electron/issues/7490",
    "id": 252015302,
    "user": {
      "login": "deepak1556",
      "id": 964386,
      "avatar_url": "https://avatars2.githubusercontent.com/u/964386?v=3",
      "gravatar_id": "",
      "url": "https://api.github.com/users/deepak1556",
      "html_url": "https://github.com/deepak1556",
      "followers_url": "https://api.github.com/users/deepak1556/followers",
      "following_url": "https://api.github.com/users/deepak1556/following{/other_user}",
      "gists_url": "https://api.github.com/users/deepak1556/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/deepak1556/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/deepak1556/subscriptions",
      "organizations_url": "https://api.github.com/users/deepak1556/orgs",
      "repos_url": "https://api.github.com/users/deepak1556/repos",
      "events_url": "https://api.github.com/users/deepak1556/events{/privacy}",
      "received_events_url": "https://api.github.com/users/deepak1556/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-06T16:26:14Z",
    "updated_at": "2016-10-06T16:26:14Z",
    "body": "@tarruda can't you use `WebContentsDelegate::ShouldCreateWebContents` to stop `webContents` creation in sandbox mode ?\n\n> meaning that window.open will return a reference to the window even if you prevent it in new-window(This could be a problem despite the crash reported in this issue)\n\nWhy would it be a problem when the associated view and `webContents` are destroyed ?\n"
  },
  {
    "url": "https://api.github.com/repos/electron/electron/issues/comments/252084026",
    "html_url": "https://github.com/electron/electron/issues/7490#issuecomment-252084026",
    "issue_url": "https://api.github.com/repos/electron/electron/issues/7490",
    "id": 252084026,
    "user": {
      "login": "sltam",
      "id": 51615,
      "avatar_url": "https://avatars3.githubusercontent.com/u/51615?v=3",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sltam",
      "html_url": "https://github.com/sltam",
      "followers_url": "https://api.github.com/users/sltam/followers",
      "following_url": "https://api.github.com/users/sltam/following{/other_user}",
      "gists_url": "https://api.github.com/users/sltam/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sltam/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sltam/subscriptions",
      "organizations_url": "https://api.github.com/users/sltam/orgs",
      "repos_url": "https://api.github.com/users/sltam/repos",
      "events_url": "https://api.github.com/users/sltam/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sltam/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-06T20:48:20Z",
    "updated_at": "2016-10-06T20:48:20Z",
    "body": "@tarruda \n\n> > I wonder why it ever worked.\n> \n> The code path followed by sandboxed popups is different. For non-sandboxed, new-window is emitted before the window/webcontents are created, so when event.preventDefault() is called the the destructor is never called.\n> For sandboxed windows the webcontents is created by content module, we just wrap it in an api::Webcontents. When the event is prevented, the v8 reference to the webContents should be lost, causing its destructor to be called.\n\nMy question was: why won't electron crash whenever any `WebContent` object is deconstructed given `EmitWithEvent` is unconditionally called from `~WebContent`?\n"
  },
  {
    "url": "https://api.github.com/repos/electron/electron/issues/comments/252127890",
    "html_url": "https://github.com/electron/electron/issues/7490#issuecomment-252127890",
    "issue_url": "https://api.github.com/repos/electron/electron/issues/7490",
    "id": 252127890,
    "user": {
      "login": "tarruda",
      "id": 842846,
      "avatar_url": "https://avatars0.githubusercontent.com/u/842846?v=3",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tarruda",
      "html_url": "https://github.com/tarruda",
      "followers_url": "https://api.github.com/users/tarruda/followers",
      "following_url": "https://api.github.com/users/tarruda/following{/other_user}",
      "gists_url": "https://api.github.com/users/tarruda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tarruda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tarruda/subscriptions",
      "organizations_url": "https://api.github.com/users/tarruda/orgs",
      "repos_url": "https://api.github.com/users/tarruda/repos",
      "events_url": "https://api.github.com/users/tarruda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tarruda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-07T00:52:28Z",
    "updated_at": "2016-10-07T00:52:28Z",
    "body": "> @tarruda can't you use WebContentsDelegate::ShouldCreateWebContents to stop webContents creation in sandbox mode ?\n\nProbably, I haven't tested it though.\n\n> Why would it be a problem when the associated view and webContents are destroyed ?\n\nNot sure, but what would happen when renderer has a reference to a child `Window` object(returned by `window.open`) and its corresponding webContents is destroyed on the main process? I'm simply assuming this is not handled automatically by the content module, since apparently `CanCreateWindow` is what determines if `window.open` will return `undefined` or a reference to the child `Window`.\n\n> My question was: why won't electron crash whenever any WebContent object is deconstructed given EmitWithEvent is unconditionally called from ~WebContent?\n\nI don't know, but my guess is that `GetWrapper` is filled later, possibly after the `new-window` event is fired. All I know is that there's a few `render-view-deleted` handlers in `lib/browser`, so it must work for non-sandboxed webContents\n"
  },
  {
    "url": "https://api.github.com/repos/electron/electron/issues/comments/254385502",
    "html_url": "https://github.com/electron/electron/issues/7490#issuecomment-254385502",
    "issue_url": "https://api.github.com/repos/electron/electron/issues/7490",
    "id": 254385502,
    "user": {
      "login": "sltam",
      "id": 51615,
      "avatar_url": "https://avatars3.githubusercontent.com/u/51615?v=3",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sltam",
      "html_url": "https://github.com/sltam",
      "followers_url": "https://api.github.com/users/sltam/followers",
      "following_url": "https://api.github.com/users/sltam/following{/other_user}",
      "gists_url": "https://api.github.com/users/sltam/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sltam/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sltam/subscriptions",
      "organizations_url": "https://api.github.com/users/sltam/orgs",
      "repos_url": "https://api.github.com/users/sltam/repos",
      "events_url": "https://api.github.com/users/sltam/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sltam/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-18T01:58:17Z",
    "updated_at": "2016-10-18T01:58:17Z",
    "body": "I adopted the `preload.js` method and the app stopped crashing predictably after `preventDefault`. However, we still see random crashes with almost the same trace. Maybe I have a valid worry that this piece of code is inherently unsafe.\n\n```\nThread 0 Crashed:: CrBrowserMain Dispatch queue: com.apple.main-thread\n0 com.github.electron.framework 0x000000010f6560a1 0x10f466000 + 2031777\n1 com.github.electron.framework 0x000000010f66ea7f 0x10f466000 + 2132607\n2 com.github.electron.framework 0x000000010f5be0f5 mate::WrappableBase::GetWrapper() + 101\n3 com.github.electron.framework 0x000000010f4cf2b9 mate::EventEmitteratom::api::WebContents::GetWrapper() + 9\n4 com.github.electron.framework 0x000000010f4d2009 bool mate::EventEmitteratom::api::WebContents::EmitWithSender(base::BasicStringPiece, std::1::allocator > > const&, content::WebContents, IPC::Message, int const&) + 89\n5 com.github.electron.framework 0x000000010f4c8a13 bool mate::EventEmitteratom::api::WebContents::Emit(base::BasicStringPiece, std::__1::allocator > > const&, int const&) + 19\n6 com.github.electron.framework 0x000000010f4c89f1 atom::api::WebContents::RenderViewDeleted(content::RenderViewHost) + 81\n7 com.github.electron.framework 0x000000010f4c7727 atom::api::WebContents::~WebContents() + 199\n8 com.github.electron.framework 0x000000010f4c7819 atom::api::WebContents::~WebContents() + 9\n9 com.github.electron.framework 0x000000010f4c78ae atom::api::WebContents::~WebContents() + 14\n10 com.github.electron.framework 0x000000010f4c78cd non-virtual thunk to atom::api::WebContents::~WebContents() + 13\n11 com.github.electron.framework 0x000000010f5be383 mate::WrappableBase::SecondWeakCallback(v8::WeakCallbackInfomate::WrappableBase const&) + 19\n12 libnode.dylib 0x00000001140e7396 v8::internal::GlobalHandles::DispatchPendingPhantomCallbacks(bool) + 854\n13 libnode.dylib 0x00000001140e742e v8::internal::GlobalHandles::PostGarbageCollectionProcessing(v8::internal::GarbageCollector, v8::GCCallbackFlags) + 46\n14 libnode.dylib 0x00000001140f68f8 v8::internal::Heap::PerformGarbageCollection(v8::internal::GarbageCollector, v8::GCCallbackFlags) + 1768\n15 libnode.dylib 0x00000001140f5d44 v8::internal::Heap::CollectGarbage(v8::internal::GarbageCollector, char const, char const, v8::GCCallbackFlags) + 676\n16 libnode.dylib 0x00000001140f5a48 v8::internal::Heap::CollectAllAvailableGarbage(char const) + 104\n17 libnode.dylib 0x0000000113d8b914 v8::Isolate::LowMemoryNotification() + 196\n18 com.github.electron.framework 0x000000010f4ff430 void base::internal::RunnableAdapter::Runv8::Isolate*(v8::Isolate&&) const + 32\n19 com.github.electron.framework 0x000000010f4ff3f9 void base::internal::InvokeHelper::MakeItSo<base::internal::RunnableAdapter<void (v8::Isolate::)()> const&, v8::Isolate>(base::internal::RunnableAdapter<void (v8::Isolate::)()> const&&&, v8::Isolate&&) + 9\n20 com.github.electron.framework 0x000000010f4ff3e1 void base::internal::Invoker<base::internal::BindState<base::internal::RunnableAdapter<void (v8::Isolate::)()>, base::internal::UnretainedWrapperv8::Isolate >, void ()>::RunImpl const&, std::__1::tuplebase::internal::UnretainedWrapper<v8::Isolate > const&, 0ul>(base::internal::RunnableAdapter const&&&, std::__1::tuplebase::internal::UnretainedWrapper<v8::Isolate > const&&&, base::IndexSequence<0ul>) + 33\n21 com.github.electron.framework 0x000000010f4ff304 base::internal::Invoker, base::internal::UnretainedWrapperv8::Isolate >, void ()>::Run(base::internal::BindStateBase*) + 20\n22 com.github.electron.framework 0x000000010f6b1269 0x10f466000 + 2404969\n23 com.github.electron.framework 0x000000010f6571bb 0x10f466000 + 2036155\n24 com.github.electron.framework 0x000000010f677f8c 0x10f466000 + 2170764\n25 com.github.electron.framework 0x000000010f67829c 0x10f466000 + 2171548\n26 com.github.electron.framework 0x000000010f67887b 0x10f466000 + 2173051\n27 com.github.electron.framework 0x000000010f64cb49 0x10f466000 + 1993545\n28 com.github.electron.framework 0x000000010f66ef4a 0x10f466000 + 2133834\n29 com.github.electron.framework 0x000000010f64c534 0x10f466000 + 1991988\n30 com.apple.CoreFoundation 0x00007fff879c74b1 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION + 17\n31 com.apple.CoreFoundation 0x00007fff879a88bc __CFRunLoopDoSources0 + 556\n32 com.apple.CoreFoundation 0x00007fff879a7da6 __CFRunLoopRun + 934\n33 com.apple.CoreFoundation 0x00007fff879a77a4 CFRunLoopRunSpecific + 420\n34 com.apple.HIToolbox 0x00007fff86f3871c RunCurrentEventLoopInMode + 240\n35 com.apple.HIToolbox 0x00007fff86f38551 ReceiveNextEventCommon + 432\n36 com.apple.HIToolbox 0x00007fff86f38386 _BlockUntilNextEventMatchingListInModeWithFilter + 71\n37 com.apple.AppKit 0x00007fff85549e11 _DPSNextEvent + 1093\n38 com.apple.AppKit 0x00007fff85cbbf0c -[NSApplication(NSEvent) _nextEventMatchingEventMask:untilDate:inMode:dequeue:] + 2730\n39 com.apple.AppKit 0x00007fff8553e7b1 -[NSApplication run] + 926\n...\n```\n"
  },
  {
    "url": "https://api.github.com/repos/electron/electron/issues/comments/255083684",
    "html_url": "https://github.com/electron/electron/issues/7490#issuecomment-255083684",
    "issue_url": "https://api.github.com/repos/electron/electron/issues/7490",
    "id": 255083684,
    "user": {
      "login": "tarruda",
      "id": 842846,
      "avatar_url": "https://avatars0.githubusercontent.com/u/842846?v=3",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tarruda",
      "html_url": "https://github.com/tarruda",
      "followers_url": "https://api.github.com/users/tarruda/followers",
      "following_url": "https://api.github.com/users/tarruda/following{/other_user}",
      "gists_url": "https://api.github.com/users/tarruda/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tarruda/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tarruda/subscriptions",
      "organizations_url": "https://api.github.com/users/tarruda/orgs",
      "repos_url": "https://api.github.com/users/tarruda/repos",
      "events_url": "https://api.github.com/users/tarruda/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tarruda/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-20T11:47:48Z",
    "updated_at": "2016-10-20T11:47:48Z",
    "body": "> Maybe I have a valid worry that this piece of code is inherently unsafe.\n\nWere you able to figure why this is not an issue on non-sandboxed renderers?\n"
  },
  {
    "url": "https://api.github.com/repos/electron/electron/issues/comments/255669721",
    "html_url": "https://github.com/electron/electron/issues/7490#issuecomment-255669721",
    "issue_url": "https://api.github.com/repos/electron/electron/issues/7490",
    "id": 255669721,
    "user": {
      "login": "zcbenz",
      "id": 639601,
      "avatar_url": "https://avatars3.githubusercontent.com/u/639601?v=3",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zcbenz",
      "html_url": "https://github.com/zcbenz",
      "followers_url": "https://api.github.com/users/zcbenz/followers",
      "following_url": "https://api.github.com/users/zcbenz/following{/other_user}",
      "gists_url": "https://api.github.com/users/zcbenz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zcbenz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zcbenz/subscriptions",
      "organizations_url": "https://api.github.com/users/zcbenz/orgs",
      "repos_url": "https://api.github.com/users/zcbenz/repos",
      "events_url": "https://api.github.com/users/zcbenz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zcbenz/received_events",
      "type": "User",
      "site_admin": true
    },
    "created_at": "2016-10-24T07:43:01Z",
    "updated_at": "2016-10-24T07:43:01Z",
    "body": "The code assumes the `WebContents` will never be deleted because of garbage collected, we always call `destroy` to delete the native wrapper when a window or webview is closed. (See the comments of `WebContents::WebContentsDestroyed` for more).\n\nSo I think the correct fix is to call `destroy` for the `WebContents` when the `event.preventDefault` is called.\n"
  },
  {
    "url": "https://api.github.com/repos/electron/electron/issues/comments/261104267",
    "html_url": "https://github.com/electron/electron/issues/7490#issuecomment-261104267",
    "issue_url": "https://api.github.com/repos/electron/electron/issues/7490",
    "id": 261104267,
    "user": {
      "login": "sltam",
      "id": 51615,
      "avatar_url": "https://avatars3.githubusercontent.com/u/51615?v=3",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sltam",
      "html_url": "https://github.com/sltam",
      "followers_url": "https://api.github.com/users/sltam/followers",
      "following_url": "https://api.github.com/users/sltam/following{/other_user}",
      "gists_url": "https://api.github.com/users/sltam/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sltam/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sltam/subscriptions",
      "organizations_url": "https://api.github.com/users/sltam/orgs",
      "repos_url": "https://api.github.com/users/sltam/repos",
      "events_url": "https://api.github.com/users/sltam/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sltam/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-11-16T23:17:37Z",
    "updated_at": "2016-11-16T23:17:37Z",
    "body": "Can someone please fix this now that the problem is diagnosed?\n\nMy experience in the last month suggests that the workaround outlined above doesn't quite work because `window.open` isn't the only way to trigger a new window. There's also `<a target>` and `<base target>`, and `preload` script doesn't affect content inside `iframe` either.\n"
  }
]