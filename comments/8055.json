[
  {
    "url": "https://api.github.com/repos/electron/electron/issues/comments/262376129",
    "html_url": "https://github.com/electron/electron/issues/8055#issuecomment-262376129",
    "issue_url": "https://api.github.com/repos/electron/electron/issues/8055",
    "id": 262376129,
    "user": {
      "login": "kevinsawicki",
      "id": 671378,
      "avatar_url": "https://avatars0.githubusercontent.com/u/671378?v=3",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kevinsawicki",
      "html_url": "https://github.com/kevinsawicki",
      "followers_url": "https://api.github.com/users/kevinsawicki/followers",
      "following_url": "https://api.github.com/users/kevinsawicki/following{/other_user}",
      "gists_url": "https://api.github.com/users/kevinsawicki/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kevinsawicki/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kevinsawicki/subscriptions",
      "organizations_url": "https://api.github.com/users/kevinsawicki/orgs",
      "repos_url": "https://api.github.com/users/kevinsawicki/repos",
      "events_url": "https://api.github.com/users/kevinsawicki/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kevinsawicki/received_events",
      "type": "User",
      "site_admin": true
    },
    "created_at": "2016-11-22T21:49:57Z",
    "updated_at": "2016-11-22T21:49:57Z",
    "body": "Looks somewhat related to https://bugs.chromium.org/p/chromium/issues/detail?id=539505#c41"
  },
  {
    "url": "https://api.github.com/repos/electron/electron/issues/comments/271364032",
    "html_url": "https://github.com/electron/electron/issues/8055#issuecomment-271364032",
    "issue_url": "https://api.github.com/repos/electron/electron/issues/8055",
    "id": 271364032,
    "user": {
      "login": "kevinsawicki",
      "id": 671378,
      "avatar_url": "https://avatars0.githubusercontent.com/u/671378?v=3",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kevinsawicki",
      "html_url": "https://github.com/kevinsawicki",
      "followers_url": "https://api.github.com/users/kevinsawicki/followers",
      "following_url": "https://api.github.com/users/kevinsawicki/following{/other_user}",
      "gists_url": "https://api.github.com/users/kevinsawicki/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kevinsawicki/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kevinsawicki/subscriptions",
      "organizations_url": "https://api.github.com/users/kevinsawicki/orgs",
      "repos_url": "https://api.github.com/users/kevinsawicki/repos",
      "events_url": "https://api.github.com/users/kevinsawicki/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kevinsawicki/received_events",
      "type": "User",
      "site_admin": true
    },
    "created_at": "2017-01-09T18:28:05Z",
    "updated_at": "2017-01-09T18:28:05Z",
    "body": "@wenkaili any more updates on this? Have you been able to reproduce it?"
  },
  {
    "url": "https://api.github.com/repos/electron/electron/issues/comments/277194511",
    "html_url": "https://github.com/electron/electron/issues/8055#issuecomment-277194511",
    "issue_url": "https://api.github.com/repos/electron/electron/issues/8055",
    "id": 277194511,
    "user": {
      "login": "towerpark",
      "id": 24645162,
      "avatar_url": "https://avatars0.githubusercontent.com/u/24645162?v=3",
      "gravatar_id": "",
      "url": "https://api.github.com/users/towerpark",
      "html_url": "https://github.com/towerpark",
      "followers_url": "https://api.github.com/users/towerpark/followers",
      "following_url": "https://api.github.com/users/towerpark/following{/other_user}",
      "gists_url": "https://api.github.com/users/towerpark/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/towerpark/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/towerpark/subscriptions",
      "organizations_url": "https://api.github.com/users/towerpark/orgs",
      "repos_url": "https://api.github.com/users/towerpark/repos",
      "events_url": "https://api.github.com/users/towerpark/events{/privacy}",
      "received_events_url": "https://api.github.com/users/towerpark/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-03T08:46:11Z",
    "updated_at": "2017-02-03T08:46:11Z",
    "body": "I've run into a crash problem with a similar call stack, but only on quitting app.\r\n　　Electron version: 1.4.9 && 1.4.15\r\n　　OS: Windows 7\r\n\r\nThough it occurs occasionally and I can't find a reliable way to reproduce it, every time my application crashes I get a similar call stack (see the details at the end of my post):\r\n- **Some thread other than the main thread in the main process crashes at trying to track a handle (say its value = N) that is already being tracked:**\r\n　　(libchromiumcontent-win\\src\\base\\win\\scoped_handle.cc)\r\n```\r\nvoid ActiveVerifier::StartTracking(HANDLE handle, const void* owner,\r\n                                   const void* pc1, const void* pc2) {\r\n  ......\r\n  AutoNativeLock lock(*lock_);\r\n\r\n  Info handle_info = { owner, pc1, pc2, base::debug::StackTrace(), thread_id };\r\n  std::pair<HANDLE, Info> item(handle, handle_info);\r\n  std::pair<HandleMap::iterator, bool> result = map_.insert(item);\r\n  if (!result.second) {\r\n    Info other = result.first->second;\r\n    base::debug::Alias(&other);\r\n    base::debug::Alias(&creation_stack_);\r\n\r\nCRASH HERE ====>    CHECK(false);  // Attempt to start tracking already tracked handle.\r\n  ......\r\n```\r\n\r\n- **At the same time, the main thread is always pending at the same place waiting for a lock to release N, which is initiated by Archive::~Archive():**\r\n```\r\nvoid ActiveVerifier::StopTracking(HANDLE handle, const void* owner,\r\n                                  const void* pc1, const void* pc2) {\r\n  ......\r\nPENDING HERE (PARAM handle = N) ====>    AutoNativeLock lock(*lock_);\r\n\r\n  HandleMap::iterator i = map_.find(handle);\r\n  if (i == map_.end()) {\r\n    base::debug::Alias(&creation_stack_);\r\n    CHECK(false);  // Attempting to close an untracked handle.\r\n  }\r\n  ......\r\n```\r\n\r\n\r\nI think the problem may be caused by the two lines in DTOR of class Archive:\r\n　　(atom\\common\\asar\\archive.cc)\r\n```\r\nArchive::~Archive() {\r\n#if defined(OS_WIN)\r\n  if (fd_ != -1) {\r\nTHIS LINE ====>    node::close(fd_);\r\n    // Don't close the handle since we already closed the fd.\r\nAND THIS LINE ====>    file_.TakePlatformFile();\r\n  }\r\n#endif\r\n}\r\n```\r\n  \r\nThey close a handle before stopping tracking it (called in TakePlatformFile), so there's a chance that the following situation occurs: \r\n1. First, the main thread closes a handle (say its value = N), which means the handle is returned to OS and become available again.\r\n2. Then the main thread is suspended (before stopping tracking is called).\r\n3. After that, another thread is resumed, creates a new handle with a value of N returned by some Windows API, and calls starting tracking. But N is still in the tracking list at this moment, so the check fails.\r\n\r\n　　\r\nThe call stack of the crashed thread:\r\n```\r\n \telectron.exe!base::debug::BreakDebugger()  Line 21\tC++\r\n \telectron.exe!logging::LogMessage::~LogMessage()  Line 751\tC++\r\n\telectron.exe!`anonymous namespace'::ActiveVerifier::StartTracking(void * handle, const void * owner, const void * pc1, const void * pc2)  Line 200 + 0x25 bytes\tC++\r\n \telectron.exe!base::win::VerifierTraits::StartTracking(void * handle, const void * owner, const void * pc1, const void * pc2)  Line 270\tC++\r\n \telectron.exe!base::win::GenericScopedHandle<base::win::HandleTraits,base::win::VerifierTraits>::Set(void * handle)  Line 75 + 0x10 bytes\tC++\r\n \telectron.exe!base::Process::Process(void * handle)  Line 24\tC++\r\n \telectron.exe!base::Process::OpenWithExtraPrivileges(unsigned long pid)  Line 59 + 0x1d bytes\tC++\r\n \telectron.exe!IPC::AttachmentBrokerPrivilegedWin::DuplicateWinHandle(const IPC::internal::HandleAttachmentWin::WireFormat & wire_format, unsigned long source_pid)  Line 146\tC++\r\n \telectron.exe!IPC::AttachmentBrokerPrivilegedWin::OnDuplicateWinHandle(const IPC::Message & message)  Line 87\tC++\r\n \telectron.exe!IPC::AttachmentBrokerPrivilegedWin::OnMessageReceived(const IPC::Message & msg)  Line 69\tC++\r\n \telectron.exe!IPC::ChannelMojo::OnMessageReceived(const IPC::Message & message)  Line 401 + 0x10 bytes\tC++\r\n        ......\r\n```\r\nThe call stack of the main thread:\r\n```\r\n \tntdll.dll!_KiFastSystemCallRet@0() \t\r\n \tntdll.dll!_ZwWaitForKeyedEvent@16()  + 0xc bytes\t\r\n \tntdll.dll!_RtlAcquireSRWLockExclusive@4()  - 0x354e3 bytes\t\r\n \telectron.exe!base::internal::LockImpl::Lock()  Line 20\tC++\r\n \telectron.exe!base::internal::LockImpl::Lock()  Line 20\tC++\r\n \telectron.exe!`anonymous namespace'::ActiveVerifier::StopTracking(void * handle, const void * owner, const void * pc1, const void * pc2)  Line 210\tC++\r\n \telectron.exe!base::win::VerifierTraits::StopTracking(void * handle, const void * owner, const void * pc1, const void * pc2)  Line 276\tC++\r\n \telectron.exe!base::File::TakePlatformFile()  Line 31 + 0x22 bytes\tC++\r\n\telectron.exe!asar::Archive::~Archive()  Line 139\tC++\r\n \telectron.exe!asar::Archive::`scalar deleting destructor'()  + 0xb bytes\tC++\r\n \telectron.exe!`anonymous namespace'::Archive::Destroy()  Line 122\tC++\r\n \telectron.exe!mate::internal::Invoker<mate::internal::IndicesHolder<0>,`anonymous namespace'::Archive *>::DispatchToCallback(base::Callback<void __cdecl(`anonymous namespace'::Archive *),1> callback)  Line 202 + 0x3 bytes\tC++\r\n \telectron.exe!mate::internal::Dispatcher<void __cdecl(`anonymous namespace'::Archive *)>::DispatchToCallback(const v8::FunctionCallbackInfo<v8::Value> & info)  Line 237\tC++\r\n        ......\r\n```"
  }
]